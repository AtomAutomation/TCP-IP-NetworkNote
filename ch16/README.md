## 16 关于I/O流分离的其他内容

### 16.1 分离I/O流

#### 16.1.1 2次I/O流分离

之前通过两种方法分离了I/O流

- 第一种是第10章的"TCP I/O过程分离"。这种方法通过调用fork函数复制出1个文件描述符，以区分输入和输出中使用的文件描述符。分开了2个文件描述符的用途

- 第二种是第15章 通过2次fdopen函数的调用，创建读模式FILE指针和写模式FILE指针。分离了输入工具和输出工具

#### 16.1.2 分离流的好处

第十章的"流"分离目的。
- 通过分开输入过程(代码)和输出过程降低实现难度
- 与输入无关的输出程序可以提高速度

第15章的"流"分离目的
- 为了将FILE指针按读模式和写模式加以区分
- 可以通过区分读写模式降低实现难度
- 通过区分I/O缓冲提高缓冲性能

#### 16.1.3 流分离带来的EOF问题

第7章介绍EOF的传递方法和半关闭的必要性。
> shutdown(sock, SHUT_WR)

第10章的流分离没有问题，但是15章的基于fdopen函数的流则不同，我们不知道在这种情况下如何进行半关闭，我们先尝试针对输出模式的FILE指针调用fclose函数这种错误的方法

[sep_clnt.c](./sep_clnt.c)

[sep_serv.c](./sep_serv.c)

```
gcc sep_clnt.c -o clnt
gcc sep_serv.c -o serv
./serv 9190
./clnt 127.0.0.1 9190
```

