## 1.12 I/O复用

并发服务器的第二种实现方法，基于I/O复用的服务器端构建

### 12.1 基于I/O复用的服务器端

#### 12.1.1 多进程服务器端的缺点和解决办法

创建进程时需要付出很大代价，需要大量的运算和内存空间。由于每个进程都具有独立的内存空间，所以相互间的数据交换也要求采用相对复杂的方法。

#### 12.1.2 理解复用

复用: 为了提供物理设备的效率，用最少的物理要素传递最多的数据时使用的技术

例如

![](https://camo.githubusercontent.com/d2da885b77c22fefc13eb758dfb5fb59f351dc6d/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b41384838312e706e67)

![](https://camo.githubusercontent.com/b05b0c747874b9f5f364492bcf0bd2708df3f8ae/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b41386267782e706e67)

#### 12.1.3 复用技术在服务器端的应用

![](https://camo.githubusercontent.com/03203c86a3a582f48514883546a979afa9f668c9/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b4147424d362e706e67)

![](https://camo.githubusercontent.com/d206a33c936ccd52bb967c9d9cdece20240b1ad9/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b414772714f2e706e67)

从图上可以看出，引入复用技术之后，可以减少进程数。重要的是，无论连接多少客户端，提供服务的进程只有一个。

### 12.2 理解select函数并实现服务器端

使用select函数可以将多个文件描述符集中到一起监视，项目(监视项被称为事件)如下
- 是否存在套接字接收数据
- 无需阻塞传输数据的套接字有哪些
- 哪些套接字发生了异常

select函数的调用过程:

![](https://camo.githubusercontent.com/17157a29cab47b95b75dac565fb29194fd6e948d/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b41746452732e706e67)

#### 12.2.1 设置文件描述符

select函数可以同时监视多个文件描述符即监视套接字。 将要监视的文件描述符集中，然后分为(接收，传输，异常)三类。

使用fd_set数组变量，该数组变量只存有0和1,1代表该文件描述符是监视对象。

![](https://camo.githubusercontent.com/96f1fcf063bab59f1eb72bb296a697812ea0dee2/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b41743269342e706e67)

操作：
- FD_ZERO(fd_set *fdset)：将 fd_set 变量所指的位全部初始化成0
- FD_SET(int fd,fd_set *fdset)：在参数 fdset 指向的变量中注册文件描述符 fd 的信息
- FD_SLR(int fd,fd_set *fdset)：从参数 fdset 指向的变量中清除文件描述符 fd 的信息
- FD_ISSET(int fd,fd_set *fdset)：若参数 fdset 指向的变量中包含文件描述符 fd 的信息，则返回「真」

上述函数中，FD_ISSET 用于验证 select 函数的调用结果，通过下图解释这些函数的功能：

![](https://camo.githubusercontent.com/a225b58d7bf8fbbda21429a167a88dac36f975e4/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b414e5237382e706e67)

#### 12.2.2 设置检查(监视)范围及超时

select函数
```c++
#include <sys/select.h>
#include <sys/time.h>
// 成功时返回大于0的值(发生事件的文件描述符数量)，失败时返回-1，超时返回0
int select(int maxfd,fd_set * readset, fd_set * writeset, fd_set * exceptset, const struct timeval * timeout);
/*
maxfd ：监视对象文件描述符的数量
readset: 将所以关注'是否存在待读取数据'的文件描述符注册到fd_set型变量，并传递其地址符
writeset:将所以关注'是否存在传输无阻塞数据'的文件描述符注册到fd_set型变量，并传递其地址符
exceptset: 将所以关注'是否发生异常'的文件描述符注册到fd_set型变量，并传递其地址符
timeout: 调用select函数后，为防止陷入无限阻塞的状态，传递超时信息
*/
```
**文件描述符的监视(检查)范围是?**

文件描述符的监视范围与select函数的第一个参数有关，只需将最大的文件描述符值加一在传递到select函数即可。加一是因为文件描述符的值从0开始

**如何设定select函数的超时时间？**

与最后一个参数有关.本来select函数只有监视的文件描述符发生变化时才返回，选择超时也能返回0。如果不想设置超时，则传递NULL
```
struct timeval
{
    long tv_sec;
    long tv_usec;
};
```

#### 12.2.3 调用select函数后查看结果

向 select 函数的第二到第四个参数传递的 fd_set 变量中将产生如图所示的变化：

![](https://camo.githubusercontent.com/47c7da013eabf5a3cd35c1a909dac62f333ab00a/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32332f6b41303664782e706e67)

可知，select函数调用完成后，值仍未1的位置上的文件描述符发生变化

#### 12.2.4 select函数调用示例

[select.c](./select.c)

```
gcc select.c -o select
./select
```

![](https://s2.ax1x.com/2019/02/12/kwEx7F.png)

可以看出，如果运行后在标准输入流输入数据，就会在标准输出流输出数据，但是如果 5 秒没有输入数据，就提示超时。

#### 12.2.5 实现I/O复用服务器端

[echo_selectserv.c](./echo_selectserv.c)

```
gcc echo_selectserv.c -o selserv
./selserv 9199
```

![](https://s2.ax1x.com/2019/02/12/kwZwIe.png)

### 12.3 基于windows的实现

暂略

### 12.4 习题

> 以下答案仅代表本人个人观点，可能不是正确答案。

1. **请解释复用技术的通用含义，并说明何为 I/O 复用。**

答: 为了提供物理设备的效率，用最少的物理要素传递最多的数据时使用的技术.IO复用就是进程预先告诉内核需要监视的IO条件，使得内核一旦发现进程指定的一个或多个IO条件就绪，就通过进程进程处理，从而不会在单个IO上阻塞了。

[Linux网络编程-IO复用技术](https://www.cnblogs.com/luoxn28/p/6220372.html)

2. **多进程并发服务器的缺点有哪些？如何在 I/O 复用服务器中弥补？**

答：创建进程消耗大量内存与资源，I/O复用通过select函数监听套接字，通过得知是那个套接字的变化来完成对应操作

3. **复用服务器端需要 select 函数。下列关于 select 函数使用方法的描述正确的是？**

答：加粗为正确的
- 调用 select 函数前需要集中 I/O 监视对象的文件描述符
- **若已通过 select 函数注册为监视对象，则后续调用 select 函数时无需重复注册**
- 复用服务器端同一时间只能服务于 1 个客户端，因此，需要服务的客户端接入服务器端后只能等待
- **与多线程服务端不同，基于 select 的复用服务器只需要 1 个进程。因此，可以减少因创建多进程产生的服务器端的负担。**

4. **select 函数的观察对象中应包含服务端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因。**

答：应该包含到「是否存在待读取数据」