## 1.10 多进程服务器端

### 10.1 进程概念及应用

根据之前学到的内容，我们可以构建按序向第一个客户端到第一百个客户端提供服务的服务器端，不过这样第一百个的客户端需要很长时间的等待后才能得到服务，所以我们需要多并发。

#### 10.1.1 并发服务器端的实现方法

使服务器能同时向所有发起请求的客户端提供服务。而且网络程序中数据通信的时间比CPU运算时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。

实现方法与模型
- 多进程服务器： 通过创建多个进程提供服务
- 多路复用服务器： 通过捆绑并统一管理I/O 对象提供服务
- 多路线服务器: 通过生成与客户端等量的线程提供服务

#### 10.1.2 理解进程(Process)

进程: 占用内存空间的正在运行的程序

#### 10.1.3 进程ID

所有进程都会从操作系统分配到ID，'进程ID'，其值为大于2的整数，1要分配给操作系统启动后的(用于协助操作系统)首个进程，因此用户进程无法得到ID值1。

通过ps指令可以查看当前运行的所有进程，该指令同时列出了PID(进程ID)，另外，通过指定a和u参数也能列出所有进程的详细信息

```
ps au
```
![](https://s2.ax1x.com/2019/02/06/kYHjeJ.png)

#### 10.1.4 通过调用fork函数创建进程

用于创建多进程服务器端的fork函数

```c++
#include <unistd.h>
// 成功时返回进程ID，失败时返回-1
pid_t fork(void);
```

fork函数将创建调用的进程副本，也就是说并非根据完全不同的程序来创建进程，而是复制正在运行的，调用fork函数的进程。另外，两个进程都经执行fork函数调用后的语句(准确来说是在fork函数返回后)。因为是同一个进程，复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分，即利用fork函数如下特点区分程序执行流程
- 父程序: fork函数返回子程序Id
- 子程序：fork函数返回0

![](https://camo.githubusercontent.com/4fb5bd2a643a26de90075dc6894e7102c2fb6ce2/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32302f356334336461353431326239302e706e67)

同上图可知，父进程通过调用fork函数的同时复制出子进程，并分别得到fork函数的返回值。但复制前，复制前父进程将全局变量gval增加到11,将局部变量lval的值增加到25,因此在这种状态下完成复制。复制完成后根据fork函数的返回类型区分父子进程。父进程将lval的值加1，但这不会影响子进程的lval值.同样，子进程将gval的值加1也不会影响到父进程的gval。因为fork函数调用后分层了两个完全不同的进程，只是二者共享同一代码而已。

程序

[fork.c](./fork.c)

```
gcc fork.c -o fork
./fork
```
![](https://s2.ax1x.com/2019/02/08/kNuZdg.png)

从运行结果可以知道，调用fork函数后，父子进程将拥有完全独立的内存结构。

### 10.2 进程和僵尸进程

#### 10.2.1 僵尸进程

进程完成工作后应该被销毁，但有些进程未被正确销毁，平白占用系统资源。

#### 10.2.2 产生僵尸进程的原因

例如用如下两个示例调用fork函数产生子进程的终止方式
- 传递参数并调用exit函数
- main函数中执行return 语句并返回值

向exit函数传递的参数值和main函数的return 语句返回的值都会传递给操作系统。`而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程`，处于这种状态下的进程就是僵尸进程。

如何向父进程传递这些值? 

只有父进程主动发起请求(函数调用)时，操作系统才会传递该值。也就是说父进程为主动要求获得子进程的结束状态值时，操作系统将一直保存并让子进程处于僵尸进程状态

创建僵尸进程的例子

[zombie.c](./zombie.c)

```
gcc zombie.c -o zombie
./zombie
```
![](https://s2.ax1x.com/2019/02/08/kNKPk4.png)
```
ps au
```
![](https://s2.ax1x.com/2019/02/08/kNKitJ.png)

可知父进程暂停30s，但是父子进程是同时销毁的。

后台处理是指将控制台窗口中的指令放在后台运行的方式(& 将触发后台命令)
```
./zombie &
```
就可以在同一控制台输入命令无需打开新的命令台

#### 10.2.3 销毁僵尸进程 1: 利用wait函数

为了销毁子进程，父进程应该主动请求获取子进程的返回值。

```c++
#include <sys/wait.h>
// 成功时返回终止的子进程ID，失败时返回-1
pid_t wait(int *statloc);
```
调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值(exit函数的参数值，main函数的return返回值)将保存到该函数的参数所指的内存空间。但函数参数指向的单位中还包含其他信息，因此需要通过下列宏进行分类
- WIFEXITED 子进程正常终止时返回'真'(true)
- WEXITSTATUS返回子进程的返回值