## 1.10 多进程服务器端

### 10.1 进程概念及应用

根据之前学到的内容，我们可以构建按序向第一个客户端到第一百个客户端提供服务的服务器端，不过这样第一百个的客户端需要很长时间的等待后才能得到服务，所以我们需要多并发。

#### 10.1.1 并发服务器端的实现方法

使服务器能同时向所有发起请求的客户端提供服务。而且网络程序中数据通信的时间比CPU运算时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。

实现方法与模型
- 多进程服务器： 通过创建多个进程提供服务
- 多路复用服务器： 通过捆绑并统一管理I/O 对象提供服务
- 多路线服务器: 通过生成与客户端等量的线程提供服务

#### 10.1.2 理解进程(Process)

进程: 占用内存空间的正在运行的程序

#### 10.1.3 进程ID

所有进程都会从操作系统分配到ID，'进程ID'，其值为大于2的整数，1要分配给操作系统启动后的(用于协助操作系统)首个进程，因此用户进程无法得到ID值1。

通过ps指令可以查看当前运行的所有进程，该指令同时列出了PID(进程ID)，另外，通过指定a和u参数也能列出所有进程的详细信息

```
ps au
```
![](https://s2.ax1x.com/2019/02/06/kYHjeJ.png)

#### 10.1.4 通过调用fork函数创建进程

用于创建多进程服务器端的fork函数

```c++
#include <unistd.h>
// 成功时返回进程ID，失败时返回-1
pid_t fork(void);
```

fork函数将创建调用的进程副本，也就是说并非根据完全不同的程序来创建进程，而是复制正在运行的，调用fork函数的进程。另外，两个进程都经执行fork函数调用后的语句(准确来说是在fork函数返回后)。因为是同一个进程，复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分，即利用fork函数如下特点区分程序执行流程
- 父程序: fork函数返回子程序Id
- 子程序：fork函数返回0

![](https://camo.githubusercontent.com/4fb5bd2a643a26de90075dc6894e7102c2fb6ce2/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32302f356334336461353431326239302e706e67)

同上图可知，父进程通过调用fork函数的同时复制出子进程，并分别得到fork函数的返回值。但复制前，复制前父进程将全局变量gval增加到11,将局部变量lval的值增加到25,因此在这种状态下完成复制。复制完成后根据fork函数的返回类型区分父子进程。父进程将lval的值加1，但这不会影响子进程的lval值.同样，子进程将gval的值加1也不会影响到父进程的gval。因为fork函数调用后分层了两个完全不同的进程，只是二者共享同一代码而已。

程序

[fork.c](./fork.c)

```
gcc fork.c -o fork
./fork
```
![](https://s2.ax1x.com/2019/02/08/kNuZdg.png)

从运行结果可以知道，调用fork函数后，父子进程将拥有完全独立的内存结构。

### 10.2 进程和僵尸进程

#### 10.2.1 僵尸进程

进程完成工作后应该被销毁，但有些进程未被正确销毁，平白占用系统资源。

#### 10.2.2 产生僵尸进程的原因

例如用如下两个示例调用fork函数产生子进程的终止方式
- 传递参数并调用exit函数
- main函数中执行return 语句并返回值

向exit函数传递的参数值和main函数的return 语句返回的值都会传递给操作系统。`而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程`，处于这种状态下的进程就是僵尸进程。

如何向父进程传递这些值? 

只有父进程主动发起请求(函数调用)时，操作系统才会传递该值。也就是说父进程为主动要求获得子进程的结束状态值时，操作系统将一直保存并让子进程处于僵尸进程状态

创建僵尸进程的例子

[zombie.c](./zombie.c)

```
gcc zombie.c -o zombie
./zombie
```
![](https://s2.ax1x.com/2019/02/08/kNKPk4.png)
```
ps au
```
![](https://s2.ax1x.com/2019/02/08/kNKitJ.png)

可知父进程暂停30s，但是父子进程是同时销毁的。

后台处理是指将控制台窗口中的指令放在后台运行的方式(& 将触发后台命令)
```
./zombie &
```
就可以在同一控制台输入命令无需打开新的命令台

#### 10.2.3 销毁僵尸进程 1: 利用wait函数

为了销毁子进程，父进程应该主动请求获取子进程的返回值。

```c++
#include <sys/wait.h>
// 成功时返回终止的子进程ID，失败时返回-1
pid_t wait(int *statloc);
```
调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值(exit函数的参数值，main函数的return返回值)将保存到该函数的参数所指的内存空间。但函数参数指向的单位中还包含其他信息，因此需要通过下列宏进行分类
- WIFEXITED 子进程正常终止时返回'真'(true)
- WEXITSTATUS 返回子进程的返回值

```c++
int status;
wait(&status);
if(WIFEXITED(status)) // 是正常终止的嘛
{
    puts("正常终止");
    printf("子进程返回值为  %d", WEXITSTATUS(status) );
}
```

[wait.c](./wait.c)

```
gcc wait.c -o wait
./wait
```

![](https://s2.ax1x.com/2019/02/09/kN2Eo8.png)

![](https://s2.ax1x.com/2019/02/09/kN2eJg.png)

通过调用ps au 命令可发现只有父进程，没有子进程，这是因为调用了wait函数，完全销毁了该程序，另外两个子进程终止时返回的3和7传递到了父进程

调用wait函数时，如果没有已终止的子进程，那么程序将阻塞直到有子进程终止，因此需要谨慎调用该函数

#### 10.2.4 销毁僵尸进程 2：  使用waitpid函数

```c++
#include <sys/wait.h>
// 成功时返回终止的子进程ID(或 0)，失败时返回-1
pid_t waitpid(pid_t pid, int * statloc,int options);

/*
pid 等待终止的目标子进程ID，若传递-1，则与wait函数相同，可以等待任意子进程终止
statloc 与wait函数的statloc参数具有相同含义
options 传递常量 WNOHANG ，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数
*/
```
调用waitpid函数时，程序不会阻塞

[waitpid.c](./waitpid.c)

```
gcc waitpid.c -o waitpid
./waitpid
```

![](https://s2.ax1x.com/2019/02/09/kNRkc9.png)

可以看出共执行了5此输出sleep，说明waitpid 函数并未阻塞

### 10.3 信号处理

子进程究竟何时终止? 调用waitpid函数后要无休止的等待吗？

#### 10.3.1 向操作系统求助

子进程终止的识别主体是操作系统，因此操作系统若能告诉父进程，子进程的终止。然后父进程可以暂时放下工作用于处理子进程的终止。

信号处理机制:  信号指特定事件发生时由操作系统向进程发送的信息

#### 10.3.2 关于JAVA的题外话: 保持开发思维

JAVA在编程语言层面支持进程或线程，但C语言及c++语言并不支持.JAVA为了保持平台移植性，以独立于操作系统的方式提供进程和线程的创建方法

#### 10.3.3 信号与signal函数

进程发现直接子进程结束时，请求操作系统调用特定函数，该请求通过调用signal函数完成(也成该函数为信号注册函数)

```c++
#include <signal.h>

void (* signal(int signo, void (*func)(int)))(int);
// 为了在产生信号时调用，返回之前注册的函数指针
```

第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值(指针),发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给出signal中注册的部分特殊情况
- SIGALRM ： 已到通过调用alarm函数注册的时间
- SIGINT ：  输入CTRL + C
- SIGCHLD ： 子进程终止

```c++
signal(SIGCHLD,mychild);
```

信号注册后，发生注册信号时(注册的情况发生时)，操作系统将调用对应函数。

```c++
#include<unistd.h>

unsigned int alarm (unsigned int seconds);
// 返回0 或 秒为单位的距SIGALRM信号发生所剩时间
```
如果调用该函数的同时传递一个正整数型，相应时间后(以秒为单位)将产生SIGALRM信号，若传递0 ，则之前对SIGSLRM信号的预约将取消。如果通过该函数预约信号后为指定该信号对应的处理函数，则(通过调用signal)终止进程。

[signal.c](./signal.c)

```
gcc signal.c -o signal
./signal
```

上面没任何输入，下面输入了CTRL+ C

![](https://s2.ax1x.com/2019/02/09/kUpwPU.png)

我们要知道，发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程，因为进程处于睡眠状态时无法调用函数。而且，进程一旦被唤醒，就会再进入睡眠状态，即使未到sleep函数中规定的时间。


#### 10.3.4 利用sigaction 函数进行信号处理

sigaction比signal更稳定，可以取代后者。因为signal函数在UNIX系列的不同操作系统中可能存在区别，而sigaction没有不同

```c++
#include <signal.h>
// 成功时返回0，失败时返回-1 
int sigaction(int signo, const struct sigaction *act , struct sigaction *oldact);
/*
signo : 与signal函数相同，传递信号信息
act: 对于第一个参数的信号处理函数（信号处理器）信息。
oldact: 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0
*/
```
声明并初始化 sigaction 结构体变量以调用上述函数，该结构体定义如下：
```c++
struct sigaction
{
    // sa_handler 成员保存信号处理函数的指针值(地址值)
    void (*sa_handler)(int);

    // sa_mask和sa_flags的所有位默认初始化为0
    sigset_t sa_mask;
    int sa_flags;
};
```

[sigaction.c](./sigaction.c)

```
gcc sigaction.c -o sigaction
./sigaction
```
![](https://s2.ax1x.com/2019/02/09/kUkRII.png)

#### 10.3.5 利用信号处理技术消灭僵尸进程

子进程终止时将尝试SIGCHLD信号，利用这一点，我们可以完成消灭僵尸进程

[remove_zomebie.c](./remove_zomebie.c)

```
gcc remove_zomebie.c -o zombie
./zombie
```
![](https://s2.ax1x.com/2019/02/09/kUAlTA.png)

### 10.4 基于多任务的并发服务器

#### 10.4.1 基于进程的并发服务器模型

![](https://camo.githubusercontent.com/fc1ea110db4649c68d5d42335c9806295113c626/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32312f356334353336363463646532362e706e67)

可以看出，每当有客户端请求服务(连接请求)时，回声服务器端都创建子进程提供服务。步骤
- 1. 回声服务器端(父进程)通过调用accept函数受理连接请求。
- 2. 此时获取的套接字文件描述符创建并传递给子进程。
- 3. 子进程利用传递来的文件描述符提供服务

因为子进程赋值父进程拥有的所有资源，实际上不要另外经过传递文件描述符的过程

#### 10.4.2 实现并发服务器

[echo_mpserv.c](./echo_mpserv.c)

[echo_client.c](./echo_client.c)

![](https://s2.ax1x.com/2019/02/10/kUstIg.png)

服务端支持同时给多个客户端进行服务，每有一个客户端连接服务端，就会多开一个子进程，所以可以同时提供服务。

#### 10.4.3 通过fork函数复制文件描述符

fork函数时复制父进程的所有资源，但是套接字不属于进程，进程拥有的是套接字的文件描述符。

![](https://camo.githubusercontent.com/bccc953858430623a748bce77a5328554a154f58/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b5037526a782e706e67)

如图所示，一个套接字中存在两个文件描述符，只有当2个文件描述符都被销毁后，才能销毁相应套接字。

![](https://camo.githubusercontent.com/606ff8c735a23218097a755cbdcf7eb4ed0b5dbe/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b5048375a542e706e67)

### 10.5 分割TCP的I/O程序

what: 创建子进程，让父进程只负责接收数据，子进程负责写数据。这样，无论客户端是否从服务器端接收完数据都可以进行传输

![](https://camo.githubusercontent.com/2e47a1898c432b48ce0adec7c850cf783ee83564/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b5062686b442e706e67)

分割I/O程序可以提高频繁交换数据的程序的性能，如下图所示

![](https://camo.githubusercontent.com/c8ee16967cc8f5fa4f03c87b3d1cb625600cd83c/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b50627674672e706e67)

分割I/O后的客户端发送数据不必考虑接收数据的情况，因此可以连续发送数据

#### 10.5.1 回声客户端的I/O程序分割

[echo_mpclient.c](./echo_mpclient.c)

### 10.6 习题

> 以下答案仅代表本人个人观点，可能不是正确答案。

1. **下列关于进程的说法正确的是？**

答：以下加粗的是正确的

- **从操作系统的角度上说，进程是程序运行的单位**
- **进程根据创建方式建立父子关系**
- 进程可以包含其他进程，即一个进程的内存空间可以包含其他进程
- **子进程可以创建其他子进程，而创建出来的子进程还可以创建其他子进程，但所有这些进程只与一个父进程建立父子关系。**

2. **调用 fork 函数将创建子进程，一下关于子进程正确的是？**

答：以下加粗的是正确的

- 父进程销毁时也会同时销毁子进程
- **子进程是复制父进程所有资源创建出的进程**
- 父子进程共享全局变量
- 通过 fork 函数创建的子进程将执行从开始到 fork 函数调用为止的代码。

3. **创建子进程时复制父进程所有内容，此时复制对象也包含套接字文件描述符。编写程序验证赋值的文件描述符整数值是否与原文件描述符数值相同。**

答：[text.c](./text.c)

![](https://s2.ax1x.com/2019/02/10/kU2Uvd.png)

4. **请说明进程变为僵尸进程的过程以及预防措施。**

答: 子进程完成后其实未被销毁，等到父进程销毁或着父进程主动要求得到子进程的结束状态值后，子进程才会销毁。预防措施，调用wait函数或waitid函数使父进程得到子进程的结束状态

