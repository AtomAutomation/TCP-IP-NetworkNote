## 15 套接字和标准I/O 

### 15.1 标准I/O 函数的优点

#### 15.1.1 标准I/O的两个优点

- 标准 I/O 函数具有良好的移植性
- 标准 I/O 函数可以利用缓冲提高性能

良好移植性： 标准函数时按照ANSIC标准定义的

额外的缓冲: 创建套接字时，操作系统会生成用于I/O的缓冲，而若使用标准I/O函数

![](https://camo.githubusercontent.com/fa4d05ae67e35866b82fbe9e0084f50c0e0fc595/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32392f356335303065353361643961612e706e67)

假设使用 fputs 函数进行传输字符串 「Hello」时，首先将数据传递到标准 I/O 缓冲，然后将数据移动到套接字输出缓冲，最后将字符串发送到对方主机。

设置缓冲的目的是为了提高性能，套接字中的缓冲主要是为了实现TCP协议而设立的(如再次发送丢失的数据)，I/O函数缓冲是为了提供性能

- 传输的数据量
- 数据向输出缓冲移动的次数

发送10个每个为1字节的数据包和发送一个10字节的数据包，显然因为头信息的存在，10个数据包会传输更多数据量，而且为了发送数据，向套接字输出缓冲移动数据也会消耗不少时间

#### 15.1.2 标准I/O和系统函数之间的性能对比

对于未提供缓冲的read和write函数来说，传输很慢，而标准I/O输入则较快

#### 15.1.3 标准I/O函数的几个缺点

- 不容易进行双向通信
- 有时可能频繁调用fflush函数
- 需要以FILE结构体指针的形式返回文件描述符

打开文件时，如果希望同时进行读写操作，则应以r+，w+，a+模式打开，但因为缓冲的缘故，每次切换读写工作状态时应调用fflush函数。这也会影响基于缓冲的性能提高。而且为了使用标准I/O函数，需要FILE结构体指针。而创建套接字时默认返回文件描述符，所以需要将文件描述符转化为FILE指针

### 15.2 使用标准I/O函数

#### 15.2.1 利用fdopen函数转换为FILE结构体指针

通过fdopen函数将创建套接字时返回的文件描述符转化为标准I/O中的FILE结构体指针

```c++
#include <stdio.h>
// 成功时返回转换的FILE结构体指针，失败时返回NULL
FILE *fdopen(int fildes, const char * mode);
/*
fildes : 需要转换的文件描述符
mode   : 将要创建的FILE结构体指针的模式(mode)信息
*/
```

[desto.c](./desto.c)

```
gcc desto.c -o desto
./desto
cat data.dat
```

![](https://s2.ax1x.com/2019/02/19/kgNOtP.png)

文件描述符转换为 FILE 指针，并可以通过该指针调用标准 I/O 函数。

#### 15.2.2 利用fileno函数转换为文件描述符

```c++
#include <stdio.h>
// 成功时返回转换后的文件描述符，失败时返回-1
int fileno(FILE　* stream);
```

[todes.c](./todes.c)

![](https://s2.ax1x.com/2019/02/19/kgUYcD.png)

### 15.3 基于套接字的标准I/O函数使用

把第四章的回声客户端和回声服务端的内容改为基于标准 I/O 函数的数据交换形式。

[echo_client.c](./echo_client.c)

[echo_stdserv.c](./echo_stdserv.c)

```
gcc echo_client.c -o eclient
gcc echo_stdserv.c -o eserver
```

### 15.4 习题

> 以下答案仅代表本人个人观点，可能不是正确答案

1. **请说明标准 I/O 的 2 个优点。他为何拥有这 2 个优点？**

答：1.具有良好移植性，2. 可以利用缓冲提供性能。  标准函数是按ANSIC标准定义的，标准I/O有额外的缓冲

2. **利用标准 I/O 函数传输数据时，下面的说法是错误的：**

> 调用 fputs 函数传输数据时，调用后应立即开始发送！

**为何上述说法是错误的？为达到这种效果应该添加哪些处理过程？**

答: 只是传输到了缓冲中，需要利用fflush函数刷新缓冲区

